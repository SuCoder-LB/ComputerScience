### 命令

~~~
ps -A显示当前所有进程
top查看进程运行状态，cpu利用率，内存使用情况
ps -aux|grep PID 查看某PID进程状态
free -m查看内存使用情况
tar 解压
    必选参数
    -c建立压缩档案，-x解压，-t查看内容，-r，向压缩归档文件末尾追加文件 -u更新原压缩包中的文件
    可选参数
    -z有gzip属性的，-j有bz2属性的，-z有compress属性的，-v显示所有过程，-o将文件解开到标准输出
chmod修改权限 owner（rwx）group，others
cd切换目录
ls查看当前文件与目录
grep
cp复制命令
mv移动文件或文件夹
rm删除文件或文件夹
ps查看进程情况
kill向进程发送终止信号
tar文件打包，调用gzip或bzip进行压缩或解压
cat，less，more查看文件内容
pwd显示工作目录
sudo chown root app   sudo chmod u+s app以root权限运行程序
~~~

### 软链接与硬链接

+ 软链接
  - 符号链接，包含另一个文件的路径名，可以链接不同文件系统的文件，可对不存在的文件或目录创建软链接，可交叉文件系统，删除不影响被指向的文件，若指向的源文件被删除，相关链接称为死链接，若被指向路径文件被重新创建，恢复正常
+ 硬链接
  - 一个文件的一个或多个文件名，把文件名和计算机文件系统使用的节点号链接起来，可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录，只能对已有文件创建，不能交叉文件系统创建，不能对目录创建，删除文件不影响其他有相同inode号的文件

### 静态库与动态库

+ 静态库
  - 代码装载快，执行速度快，体积大，编译时加载，windows .lib，linux .a
    动态库
  - 节省内存，可执行文件体积小，运行时加载，windows .dll，linux .so

### 大小端

+ 小端
  - 低的有效字节存储在低的存储器地址，一般为主机字节序，常用的x86结构，arm，dsp
+ 大端
  - 高的有效字节存储在低的存储器地址，网络字节序，keil c51
+ 根据联合体判断，联合体变量总是从低地址存储

~~~
inf fun1(){
  union test{
    char c;
    int i;
  };
  test t;t.i=1;
  return t.c==1
}
~~~

### 进程调度
+ 先来先服务
+ 短作业优先
+ 高优先级调度
+ 时间片轮转
+ 多级反馈

### 进程
+ 一个程序在一个数据集合上的一次运行过程
+ 程序是指令数据及其组织形式的描述，进程是程序的运行实例，包括程序计数器，寄存器，变量的当前值
+ 包含多个线程
+ 进程挂掉不影响其他进程
+ 系统资源调度的最小单位
+ 进程系统开销大于线程开销
+ 执行时拥有独立的内存单元
+ 进程切换需要刷新TLB获取新的地址空间，然后切换硬件上下文和内核栈
+ 进程适应于多核，多机分布

### 孤儿进程与僵尸进程
+ 孤儿进程
  - 父进程退出后，一个或多个子进程还在运行，这些进程将被init进程收养，由init进程对它们完整状态收集工作
+ 僵尸进程
  - 一个进程使用fork创建子进程，子进程退出，父进程并没有调用wait或waitpid系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，占用系统资源
  + 解决措施
    - fork子进程后进士wait
    - 子进程退出，内核给父进程一个sigchld信号，建立一个捕获sigchld信号的信号处理函数，在函数体中调用wait或waitpid
    - 使用kill

### 守护进程
+ 运行在后台的生存期长的特殊进程，独立于控制终端，处理系统级别任务
~~~
int pid=fork();//创建进程
if(pid>0)exit(0);//结束父进程
else if(pid<0){
  printf("fork error!\n");
  exit(1)//fork失败，退出
}
setsid();//子进程成为新的会话组长和进程组长，并与控制终端分离
chdir("/");//改变工作目录
umask(0);//重设文件创建掩模
for(int i=0;i<MAXFILE;++i){
  close(i);//关闭打开的文件描述符
  sleep(2);
}
return 0;
~~~

### 进程通信
+ 管道
  - 无名管道
  - 命名管道
+ 系统ipc
  - 消息队列
    - 较高级，一个消息队列可以被多个进程共享
    - 一个进程的消息太多，也可以用多余一个的消息队列（管理较复杂）
    - 共享消息队列的进程发送的消息除了信息还有一个标志，这个标志可以指明该消息奖由哪个进程或哪类进程接受
    - 每一个共享消息队列的进程针对这个队列也有自己的标志，可以用了声明自己的身份
  - 信号量
    - 使用PV操作实现同步互斥
  - 信号
    - 使用信号处理器实现同步互斥
  - 共享内存
+ 套接字socket

### 互斥器（mutex）与临界区（critical section）
+ mutex可用于进程间互斥
+ critical section用于线程之间的互斥

### 进程状态
+ 就绪
  - 当进程已分配到除CPU以外的所有必要资源，只要获得处理机便可立即执行
+ 执行
  - 进程已获得处理机，程序正在处理机上执行
+ 阻塞
  - 正在执行的进程，由于等待某个事件发生而无法执行时，放弃处理机而处于阻塞状态
  - 引起的原因
    - 等待I/O完成
    - 申请缓冲区不能满足
    - 等待信件（信号）

### 线程
+ 微进程，进程里更小粒度的执行单元，一个进程里包含多个线程并发执行任务
+ linux一个线程占大概8M内存
+ linux栈通过缺页分配内存，不是所有栈地址空间都分配内存，8M是最大消耗，实际内存消耗略大于实际需要内存（内部损耗，每个4k以内）
+ 属于一个进程
+ 线程挂掉，对应的进程挂掉
+ cpu调度的最小单位
+ 需要的系统资源更少
+ 多个线程共享进程的内存：代码段，数据段，扩展段
+ 每个线程有自己的栈段和寄存器组
+ 线程切换只需要切换硬件上下文和内核栈
+ 线程适用于多核
+ 一个线程可以有多个协程

### 线程通信
+ 临界区
+ 互斥量
+ 信号量
+ 条件变量
+ 读写锁

### 线程同步
+ 互斥锁
+ 信号量
+ 条件变量
+ 读写锁

### 死锁
+ 多个进程执行过程争夺资源造成相互等待：两只羊过桥
+ 条件
  - 互斥，一个资源每次只能被一个进程使用
  - 请求保持，进程获得资源后，对其他资源发出请求，并且不释放自己的资源
  - 不可剥夺，进程获得的资源，只能自己释放，不可剥夺
  - 环路等待，若干进程形成头尾相接的循环等待资源关系
+ 解决
  - 预防措施 
    - 资源一次性分配 
    - 可剥夺资源 
    - 资源有序分配 
    - 互斥无法被破坏，
  - 避免
    - 银行家算法，检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足其请求
  - 发生之后
    - 杀死某个激活死锁的进程

### fork
+ 开始分叉，分成两个进程，一个父进程，一个子进程
+ 子进程复制父进程的绝大部分内容，栈，缓冲区
+ 系统为子进程创建一个新的进程表项，进程id与父进程不同，父子进程是两个独立的进程
+ 虽然父子进程共享代码空间，设计写数据时子进程有自己的数据空间，数据修改时，系统为子进程申请新的页面


### 协程
+ 微线程，子程序内部执行，可在子程序内部中断，转而执行别的子程序，适当的时候返回来接着执行
+ 执行效率极高，协程直接操作栈基本没有内核切换的开销，上下文切换快，切换开销比线程更小
+ 不需要多线程的锁机制，多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高

### 内存

+ 物理内存
  - 寄存器
  - 高速缓存
  - 主存
  - 磁盘
+ 虚拟内存
  - 原因：
    - 进程地址空间不隔离导致数据被随意修改
    - 内存使用效率低
    - 程序运行地址不确定，随机为进程分配内存空间
  - 好处
    - 扩大地址内存
    - 内存保护，防止不用进程对物理内存的争夺，对特定内存地址提供写保护
    - 实现内存共享，方便进程通信
    - 避免内存碎片，物理内存不连续映射到虚拟内存上可以连续
  - 缺点
    - 需要额外构建数据结构，占用空间
    - 虚拟地址到物理地址转换增加执行时间
    - 页面换出换入耗时
    - 一页如果只有一部分数据浪费内存
    
+ 操作系统为每一个进程分配一个独立地址空间，但虚拟内存，虚拟内存与物理内存存在映射关系，通过页表寻址完成虚拟地址与物理地址的转换
+ 进程分配内存方式：brk，mmap

### 页表
+ 虚拟内存到物理内存的映射表
+ 原因：减小虚拟内存页对于的物理内存页的映射表大小

### linux系统态与用户态
+ 内核态
  - 拥有最高权限，可以访问所有系统指令
  - 进入时间：系统调用（主动），异常（被动），设备中断（被动），
+ 用户态
  - 只能访问一部分指令
+ 区分原因：安全需要，错用指令会导致系统崩溃，如：清内存，设置时针

### LRU最近最少使用
+ 实现方式：链表，hashmap
~~~
class LRUCache{
  list<pair<int,int>>cache;
  unordered_map<int,list<pair<int,int>>::iterator>map;
  int cap;
 public:
  LRUCache(int capacity)cap(capacity){}
  int get(int key){
    if(map.count(key)){
      auto temp=*map[key];
      cache.erase(map[key]);
      map.erase(key);
      cache.push_front(temp);
      map[key]=cache.begin();
      return temp.second;
    }
    return -1;
  }
  void put(int key,int value){
    if(map.count(key)){
      cache.erase(map[key]);
      map.erase(key);
    }else if(cap==cache.size()){
      auto temp=cache.back();
      map.erase(temp.first);
      cache.pop_back();
    }
    cache.push_front(pair<int,int>{key,value});
    map[key]=cache.begin();
  }
};
~~~


### 堆栈溢出
+ 堆溢出
  - 不断new对象，不释放，超内存
+ 栈溢出
  - 一次函数调用递归死循环

### 32位系统访问4g内存
+ 正常不行
+ 使用PAE技术将地址扩展到36位


### 并发并行
+ 并发
  - 单个cpu，在一个时刻只有一个进程在运行，但线程的切换时间则减少到纳秒数量级，多个任务不停来回快速切换
+ 并行
  - 多个CPU，多个进程同时运行
